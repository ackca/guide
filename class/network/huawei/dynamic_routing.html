<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<link rel="icon" href="../../../img/huawei.svg"/>
	<title>华为-动态路由协议</title>
	<script src="../../../js/public/head.js"></script>
	<script type="text/javascript">
		window.onload = createNavigation(dynamic_routing);
	</script>
	<style type="text/css">
		.tdCliLogo img
        {
			height: 35px;
		}
	</style>
</head>
<body>
	<div class="container-fluid">
		<div id="divCommand">
			<script type="text/javascript">
				createInstruT0("路由选择信息协议(RIP)","i5");
					createInstruT1("基本配置","i5-1");
						createInstruT2("启用RIP");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] rip [ “1。 ]");
							instruArr[1] = createCmdInstruSpan("“1。","rip进程号，省略为默认1");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("宣告网络");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-rip-1] network “172.16.0.0。");
							instruArr[1] = createCmdInstruSpan("“172.16.0.0。","标准的主类路由前缀");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置RIP版本(默认为‘V1。)");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-rip-1] version { 1 | 2 }");
							instruArr[1] = createCmdInstruSpan("1","版本1");
							instruArr[2] = createCmdInstruSpan("2","版本2");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("关闭自动汇总");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-rip-1] summary");
							instruArr[1] = createCmdInstruSpan("默认‘关闭。自动汇总，开启命令summary always");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("手动路由汇总(限‘RIP V2。，华为支持CIDR)");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/0] rip summary-address “192.168.0.0。 “255.255.255.0。");
							instruArr[1] = createCmdInstruSpan("“192.168.0.0。","汇总地址");
							instruArr[2] = createCmdInstruSpan("“255.255.248.0。","汇总掩码");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置接口发送或接收的RIP版本");
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/0] rip version { 1 | 2 }");
							instruArr[1] = createCmdInstruSpan("1","版本1");
							instruArr[2] = createCmdInstruSpan("2","版本2");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("边界(出口)路由器通告默认路由");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-rip-1] default-route originate cost “2。");
							instruArr[1] = createCmdInstruSpan("“2。","引入的默认路由cost值");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置引入RIP的外部路由的默认cost");
							instruArr[0] = createCmdSpan("[R1-rip-1] default-cost “5。");
							instruArr[1] = createCmdInstruSpan("“5。","引入的外部路由的默认cost值，对上一条的默认路由无效");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置被动接口");
							createInstruAllTopT2("阻止以组播和广播形式发送的路由更新消息从该接口发送，单播更新不影响，任何形式的接收更新无影响");
							instruArr[0] = createCmdSpan("[R1-rip-1] silent-interface { “f0/0。 | all }");
							instruArr[1] = createCmdInstruSpan("“f0/0。","具体接口");
							instruArr[2] = createCmdInstruSpan("all","所有启用rip接口");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("RIP使用单播发送更新");
							createInstruAllTopT2("使用被动接口和单播更新实现RIP的纯单播更新，一般用于MA网络(多路访问网络)，可单向配置");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-rip-1] peer “192.168.12.2。");
							instruArr[1] = createCmdInstruSpan("“192.168.12.2。","邻居IP地址");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("使用广播发送 RIP V2 的更新");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/0] rip version 2 broadcast");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("路径控制","i5-2");
						createInstruT2("在RIP报文发出(接收)接口修改路由跳数");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/1] rip { metricin | metricout } [ “2000。 | acl-name “aclName。 | ip-prefix “preName。 ] “2。");
							instruArr[1] = createCmdInstruSpan("metricin","修改接收到路由");
							instruArr[2] = createCmdInstruSpan("metricout","修改发出路由");
							instruArr[3] = createCmdInstruSpan("“2000。","匹配标准ACL");
							instruArr[4] = createCmdInstruSpan("acl-name “aclName。","匹配ACL名");
							instruArr[5] = createCmdInstruSpan("ip-prefix “preName。","匹配前缀列表名");
							instruArr[6] = createCmdInstruSpan("“2。","增加跳数，匹配方式均省略则在该接口的对应方向所有路由均增加");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("控制路由更新","i5-3");
						instruArr[0] = createCmdSpan("[R1-rip-1] filter-policy { “2000。 | acl-name “acl_rip。 | ip-prefix “pre_rip。 } { import | export } [ “g0/0/0。 ]");
						instruArr[1] = createCmdInstruSpan("“2000。","使用标准ACL匹配，标准ACL号");
						instruArr[2] = createCmdInstruSpan("“acl_rip。","使用命名的ACL匹配，ACL名");
						instruArr[3] = createCmdInstruSpan("“pre_rip。","使用前缀列表匹配，前缀列表名");
						instruArr[4] = createCmdInstruSpan("import","控制接收的路由");
						instruArr[5] = createCmdInstruSpan("export","控制发出的路由");
						instruArr[6] = createCmdInstruSpan("“g0/0/0。","接收或发出路由的接口，省略对所有路由生效");
						createCmdInstruT2(instruArr,"huawei");

					createInstruT1("RIP认证","i5-4");
						createInstruT2("明文认证");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/1] rip authentication-mode simple “huawei。");
							instruArr[1] = createCmdInstruSpan("“huawei。","密码");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("密文认证");
							instruArr[0] = createCmdSpan("[R1] keychain “R1key。 mode absolute");
							instruArr[1] = createCmdInstruSpan("“R1key。","认证名称，只具本地意义");
							instruArr[2] = createCmdSpan("[R1-keychain] key-id “1。");
							instruArr[3] = createCmdInstruSpan("“1。","key编号");
							instruArr[4] = createCmdSpan("[R1-keychain-keyid-1] key-string “huawei。");
							instruArr[5] = createCmdInstruSpan("“huawei。","密码");
							instruArr[6] = createCmdSpan("[R1-FastEthernet0/1] rip authentication-mode md5 nonstandard keychain “R1key。");
							instruArr[7] = createCmdInstruSpan("“R1key。","认证名称");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("与BFD联动，用于某条链路的‘单跳检测，不支持多跳。","i5-5");
						createInstruT2("动态全局模式，所有启用RIP的接口都生效","i5-5-1");
							createInstruT3("启用BFD");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] bfd");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("全局启用");
								instruArr[0] = createCmdSpan("[R1-rip-1] bfd all-interfaces enable");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("某些接口不启用");
								instruArr[0] = createCmdSpan("[R1] int “g0/0/1。");
								instruArr[1] = createCmdInstruSpan("“g0/0/1。","不启用BFD的接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/1] rip bfd block");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("调整BFD参数");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-rip-1] bfd all-interfaces “参数。 “参数值。");
								instruArr[1] = createCmdInstruSpan("参数含义同普通BFD");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("动态接口模式","i5-5-2");
							createInstruT3("启用BFD");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] bfd");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("接口启用");
								instruArr[0] = createCmdSpan("[R1] int “g0/0/1。");
								instruArr[1] = createCmdInstruSpan("“g0/0/1。","启用BFD的接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/1] rip bfd enable");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("调整BFD参数");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/1] rip bfd “参数。 “参数值。");
								instruArr[1] = createCmdInstruSpan("参数含义同普通BFD");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("静态模式","i5-5-3");
							createInstruT3("支持单臂回声和普通单跳，‘不支持多跳。");
							createInstruT3("先配置单臂回声或普通单跳BFD");
							createInstruT3("与接口相关联");
								instruArr[0] = createCmdSpan("[R1] int g0/0/0");
								instruArr[1] = createCmdInstruSpan("“g0/0/0。","静态单跳的出接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/0] rip bfd static");
								createCmdInstruT3(instruArr,"huawei");

				createInstruT0("开放式最短路径优先(OSPF)","i6");
					createInstruT1("基本配置","i6-1");
						createInstruT2("启用OSPF");
							instruArr[0] = createCmdSpan("[R1] ospf [ “1。 ] router-id [ “1.1.1.1。 ]");
							instruArr[1] = createCmdInstruSpan("“1。","ospf进程号，省略为默认1");
							instruArr[2] = createCmdInstruSpan("“1.1.1.1。","Router-ID");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("宣告网络");
							instruArr[0] = createCmdSpan("[R1-ospf-1] area “0。");
							instruArr[1] = createCmdInstruSpan("“0。","所属区域号");
							instruArr[2] = createCmdSpan("[R1-ospf-1-area-0.0.0.0] network “192.168.12.1。 “0.0.0.255。");
							instruArr[3] = createCmdInstruSpan("“192.168.12.1。","IP地址");
							instruArr[4] = createCmdInstruSpan("“0.0.0.255。","通配符掩码");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("边界(出口)路由器通告默认路由");
							instruArr[0] = createCmdSpan("[R1-ospf-1] default-route-advertise [ always ] [ cost “10。 ] [ type “1。 ]");
							instruArr[1] = createCmdInstruSpan("always","无论默认路由是否有效，始终通告(默认无效不通告)");
							instruArr[2] = createCmdInstruSpan("cost “10。","路由开销");
							instruArr[3] = createCmdInstruSpan("type “1。","路由类型 OE1(1)/OE2(2)，默认OE2，只有外部开销，OE1包含内部开销");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置被动接口，OSPF报文均既不能接也不能发");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-ospf-1] silent-interface { “f0/0。 | all }");
							instruArr[1] = createCmdInstruSpan("“f0/0。","具体接口");
							instruArr[2] = createCmdInstruSpan("all","所有启用ospf接口");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改发送Hello周期(Dead周期自动变为其4倍)");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/1] ospf timer hello “20。");
							instruArr[1] = createCmdInstruSpan("“20。","发送Hello周期(单位s)");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改发送Dead周期(Hello周期不变)");
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/1] ospf timer dead “60。");
							instruArr[1] = createCmdInstruSpan("“60。","发送Dead周期(单位s)");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置OSPF最大等代价负载均衡链路数量");
							instruArr[0] = createCmdSpan("[R1-ospf-1] maximum load-balancing “8。");
							instruArr[1] = createCmdInstruSpan("“8。","链路数量");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置接口OSPF链路开销");
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/1] ospf cost  “10。");
							instruArr[1] = createCmdInstruSpan("“10。","链路开销");
							createCmdInstruT2(instruArr,"huawei");
							createInstruAllBottomT2("入方向生效，但为防止异步，两边均应修改");

						createInstruT2("修改链路开销计算公式");
							createInstruAllTopT2("默认为100Mbps/链路带宽(Mbps)，配置修改公式中的分子值，当网络中带宽大于100Mbps时修改，将分子值改为链路最大带宽");
							instruArr[0] = createCmdSpan("[R1-ospf-1] bandwidth-reference “1000。");
							instruArr[1] = createCmdInstruSpan("“1000。","分子值");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置OSPF接口优先级，默认为1，范围0~255，0表示不参与选举，只能成为DROTHER");
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/1] ospf dr-priority “10。");
							instruArr[1] = createCmdInstruSpan("“10。","优先级");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("重启OSPF进程(设置后Router Id后，需重启OSPF)");
							instruArr[0] = createCmdSpan("&lt;R1> reset ospf [ “1。 ] process ");
							instruArr[1] = createCmdInstruSpan("“1。","某个具体OSPF进程号");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置OSPF接口的类型");
							instruArr[0] = createCmdSpan("[R1-FastEthernet0/1] ospf network-type { 接口类型 }");
							instruArr[1] = createCmdInstruSpan("接口类型可选项");
							instruArr[2] = createCmdInstruSpan("　　broadcast","广播");
							instruArr[3] = createCmdInstruSpan("　　nbma","非广播");
							instruArr[4] = createCmdInstruSpan("　　p2mp","点到多点");
							instruArr[5] = createCmdInstruSpan("　　p2p","点到点");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("指定OSPF邻居地址，单向指定即可");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-ospf-1] peer “192.168.1.1。 [ dr-priority “10。 ]");
							instruArr[1] = createCmdInstruSpan("“192.168.1.1。","邻居地址");
							instruArr[2] = createCmdInstruSpan("“10。","优先级");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("多区域配置","i6-2");
						createInstruT2("区域边界路由器(ABR)：汇总区域路由");
							instruArr[0] = createCmdSpan("[R1-ospf-1] area “1。");
							instruArr[1] = createCmdSpan("[R1-ospf-1-area-0.0.0.1] abr-summary “192.168.0.0。 “255.255.252.0。 [ cost “20。 ] [ not-advertise ]");
							instruArr[2] = createCmdInstruSpan("“1。","需要汇总的区域号");
							instruArr[3] = createCmdInstruSpan("“192.168.0.0。","区域路由汇总地址");
							instruArr[4] = createCmdInstruSpan("“255.255.252.0。","路由汇总掩码");
							instruArr[5] = createCmdInstruSpan("cost “20。","修改汇总路由的开销值，路由条目中显示的开销值为设置值+到ABR开销值");
							instruArr[6] = createCmdInstruSpan("not-advertise","该汇总路由不发送(明细路由仍不发送)，可用于控制路由更新");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("自治系统边界路由器(ASBR)：汇总外部路由");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-ospf-1] asbr-summary “192.168.0.0。 “255.255.252.0。 [ not-advertise ] ");
							instruArr[1] = createCmdInstruSpan("“192.168.0.0。","区域路由汇总地址");
							instruArr[2] = createCmdInstruSpan("“255.255.252.0。","路由汇总掩码");
							instruArr[3] = createCmdInstruSpan("not-advertise","该汇总路由不发送");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("末节(stub)区域");
							createInstruT3("‘区域边界。路由器的设置");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-ospf-1-area-0.0.0.2] stub [ no-summary ]");
								instruArr[1] = createCmdInstruSpan("no-summary","完全末节区域");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("‘区域内部。路由器的设置");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-ospf-1-area-0.0.0.2] stub");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("次末节(NSSA)区域");
							createInstruT3("‘区域边界。路由器的设置");
								instruArr[0] = createCmdSpan(" R1-ospf-1-area-0.0.0.2] nssa [ no-import-route ] [  no-summary ]");
								instruArr[1] = createCmdInstruSpan("no-import-route","当此ABR同时又是ASBR时骨干区域仍收到重分发的路由，NSSA区域内部收不到");
								instruArr[2] = createCmdInstruSpan("no-summary","完全次末节区域");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("‘区域内部。路由器的设置");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-ospf-1-area-0.0.0.2] nssa [ default-route-advertise ]");
								instruArr[1] = createCmdInstruSpan("default-route-advertise","如果本nssa区域内的非ABR设备上，引入了默认路由，区域内其它路由器仍只有指向ABR的默认路由，配置此参数后，才有指向非ABR设备的默认路由，指向ABR的默认路由仍存在");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("建立虚链路(只在做虚链路‘两端。的‘ABR。上配置，在‘本方。设置‘对方。Router ID)");
							instruArr[0] = createCmdSpan("[R1-ospf-1] area “1。");
							instruArr[1] = createCmdInstruSpan("area “1。","虚链路穿越区域的区域号");
							instruArr[2] = createCmdSpan("[R1-ospf-1-area-0.0.0.1] vlink-peer “3.3.3.3。");
							instruArr[3] = createCmdInstruSpan("“3.3.3.3。","对方ABR Router ID");
							instruArr[1] = createCmdInstruSpan("default-route-advertise","对于非与本区域相连的外部路由，以默认路由表示，无此参数则无对应路由");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("控制路由更新","i6-3");
						createInstruT2("‘接收或发出匹配到的路由，不匹配的不接收或发出。");

						createInstruT2("控制接收的路由","i6-3-1");
							createInstruT3("‘任意路由器。配置，控制接收的‘任意路由。");
								instruArr[0] = createCmdSpan("[R1-ospf-1] filter-policy { “2000。 | acl-name “acl_ospf。 | ip-prefix “pre_ospf。 | route-policy “rp_ospf。 [ secondary ] } import");
								instruArr[1] = createCmdInstruSpan("“2000。","使用标准ACL匹配，标准ACL号");
								instruArr[2] = createCmdInstruSpan("“acl_ospf。","使用命名的ACL匹配，ACL名");
								instruArr[3] = createCmdInstruSpan("“pre_ospf。","使用前缀列表匹配，前缀列表名");
								instruArr[4] = createCmdInstruSpan("“rp_ospf。","使用route-policy匹配，route-policy名");
								instruArr[5] = createCmdInstruSpan("secondary","优先次优路由");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("‘ABR。配置，控制‘本区域接收的路由。");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-ospf-1-area-0.0.0.0] filter { “2000。 | acl-name “acl_ospf。 | ip-prefix “pre_ospf。 | route-policy “rp_ospf。 } import");
								instruArr[1] = createCmdInstruSpan("“2000。","使用标准ACL匹配，标准ACL号");
								instruArr[2] = createCmdInstruSpan("“acl_ospf。","使用命名的ACL匹配，ACL名");
								instruArr[3] = createCmdInstruSpan("“pre_ospf。","使用前缀列表匹配，前缀列表名");
								instruArr[4] = createCmdInstruSpan("“rp_ospf。","使用route-policy匹配，route-policy名");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("控制接发出的路由","i6-3-2");
							createInstruT3("‘ASBR。配置，控制发出的‘外部路由。");
								instruArr[0] = createCmdSpan("[R1-ospf-1] filter-policy { “2000。 | acl-name “acl_ospf。 | ip-prefix “pre_ospf。 } export [ “外部路由类型。 [ “外部路由选项。 ] ]");
								instruArr[4] = createCmdInstruSpan("“外部路由类型。","如:static、ospf");
								instruArr[5] = createCmdInstruSpan("“外部路由选项。","如:ospf的进程号");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("‘ABR。配置，控制‘本区域发出的路由。");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-ospf-1-area-0.0.0.0] filter { “2000。 | acl-name “acl_ospf。 | ip-prefix “pre_ospf。 | route-policy “rp_ospf。 } export");
								instruArr[1] = createCmdInstruSpan("“2000。","使用标准ACL匹配，标准ACL号");
								instruArr[2] = createCmdInstruSpan("“acl_ospf。","使用命名的ACL匹配，ACL名");
								instruArr[3] = createCmdInstruSpan("“pre_ospf。","使用前缀列表匹配，前缀列表名");
								instruArr[4] = createCmdInstruSpan("“rp_ospf。","使用route-policy匹配，route-policy名");
								createCmdInstruT3(instruArr,"huawei");

					createInstruT1("配置认证","i6-4");
						createInstruT2("链路认证");
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] ospf authentication-mode { simple | md5 “1。 } { plain | [ cipher ] } “huawei。");
							instruArr[1] = createCmdInstruSpan("simple","明文认证");
							instruArr[2] = createCmdInstruSpan("md5 “1。","密文认证，1为Key ID，一般设置为1");
							instruArr[3] = createCmdInstruSpan("plain","明文存储认证密钥");
							instruArr[4] = createCmdInstruSpan("cipher","密文存储认证密钥");
							instruArr[5] = createCmdInstruSpan("“huawei。","认证密钥");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("区域认证");
							instruArr[0] = createCmdSpan("[R1-ospf-1-area-0.0.0.0] authentication-mode { simple | md5 “1。 } { plain | [ cipher ] } “huawei。");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("虚链路认证");
							instruArr[0] = createCmdSpan("[R1-ospf-1-area-0.0.0.1] vlink-peer “2.2.2.2。 { simple | md5 “1。 } { plain | [ cipher ] } “huawei。");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("相关查看命令","i6-5");
						createInstruT2("查看OSPF路由信息");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] display ospf routing");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("查看OSPF邻居信息");
							instruArr[0] = createCmdSpan("[R1] display ospf peer [ brief ]");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("查看ABR和ASBR");
							instruArr[0] = createCmdSpan("[R1] display ospf abr-asbr");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("查看OSPF报错信息");
							instruArr[0] = createCmdSpan("[R1] display ospf error");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("与BFD联动，用于某条链路的‘单跳检测，不支持多跳。","i6-6");
						createInstruT2("动态全局模式，所有启用OSPF的接口都生效","i6-6-1");
							createInstruT3("启用BFD");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] bfd");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("全局启用");
								instruArr[0] = createCmdSpan("[R1-ospf-1] bfd all-interfaces enable");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("某些接口不启用");
								instruArr[0] = createCmdSpan("[R1] int “g0/0/1。");
								instruArr[1] = createCmdInstruSpan("“g0/0/1。","不启用BFD的接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/1] ospf bfd block");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("调整BFD参数");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-ospf-1] bfd all-interfaces “参数。  [ “参数值。 ]");
								instruArr[1] = createCmdInstruSpan("参数含义同普通BFD");
								instruArr[2] = createCmdInstruSpan("OSPF的BFD增加了个 frr-binding ，启用后，当BFD session DOWN后，接口也会DOWN");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("动态接口模式","i6-6-2");
							createInstruT3("启用BFD");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] bfd");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("接口启用");
								instruArr[0] = createCmdSpan("[R1] int “g0/0/1。");
								instruArr[1] = createCmdInstruSpan("“g0/0/1。","启用BFD的接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/1] ospf bfd enable");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("调整BFD参数");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/1] ospf bfd “参数。 “参数值。");
								instruArr[1] = createCmdInstruSpan("参数含义同普通BFD");
								instruArr[2] = createCmdInstruSpan("OSPF的BFD增加了个 frr-binding ，启用后，当BFD session DOWN后，接口也会DOWN");
								createCmdInstruT3(instruArr,"huawei");

				createInstruT0("中间系统到中间系统(IS-IS)","i7");
					createInstruT1("基本配置","i7-1");
						createInstruT2("启用IS-IS");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] isis [ “1。 ]");
							instruArr[1] = createCmdInstruSpan("“1。","进程ID");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置路由器的NET地址（数值为16进制）");
							instruArr[0] = createCmdSpan("[R1-isis-1] net 49.“0001。.“0000.0000.0001。.00");
							instruArr[1] = createCmdInstruSpan("“0001。","区域号");
							instruArr[2] = createCmdInstruSpan("“0000.0000.0001。","路由器的system ID，类似于OSPF的Router ID");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("宣告网络（接口宣告）");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis enable [ “1。 ]");
							instruArr[1] = createCmdInstruSpan("“1。","进程ID");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改路由器类型");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-isis-1] is-level { level-1 | level-1-2 | level-2 }");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改链路类型");
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis circuit-level { level-1 | level-1-2 | level-2 }");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改链路类型");
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis circuit-level { level-1 | level-1-2 | level-2 }");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置被动接口，IS-IS报文均既不能接也不能发");
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis silent [ advertise-zero-cost ]");
							instruArr[1] = createCmdInstruSpan("[ advertise-zero-cost ]","该接口的直连路由度量值为0");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置ISIS中的system ID到名称的映射");
							createInstruT3("动态映射，仅可配置本设备的名称映射，全局生效");
								instruArr[0] = createCmdSpan("[R1-isis-1] is-name “R1。");
								instruArr[1] = createCmdInstruSpan("“R1。","将本设备的system ID映射到的名称");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("静态映射，可配置任意system ID到设备名称的映射，但只本地有效，且优先级低于静态映射");
								instruArr[0] = createCmdSpan("[R1-isis-1] is-name map “1111.1111.1111。 “R1。");
								instruArr[1] = createCmdInstruSpan("“1111.1111.1111。","某设备的system ID");
								instruArr[2] = createCmdInstruSpan("“R1。","某设备的名称");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("路由泄漏，将L2的路由以明细形式发送给L1路由器");
							instruArr[0] = createCmdSpan("[R1-isis-1] import-route isis level-2 into level-1 filter-policy { “2000。 | acl-name “aclname。 | ip-prefix “prename。 | route-policy “polname。 }");
							instruArr[1] = createCmdInstruSpan("“2000。","通过acl匹配路由，acl号");
							instruArr[2] = createCmdInstruSpan("“aclname。","通过acl匹配路由，acl名");
							instruArr[3] = createCmdInstruSpan("“prename。","通过ip-prefix匹配路由，ip-prefix名");
							instruArr[4] = createCmdInstruSpan("“polname。","通过route-policy匹配路由，route-policy名");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改接口优先级");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis dis-priority  “100。 [ level-1 | level-2 ]");
							instruArr[1] = createCmdInstruSpan("“10。","接口优先级");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("hello包不填充0（默认会在hello中填充0到达MTU）");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis small-hello ");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("路由汇总");
							instruArr[0] = createCmdSpan("[R1-isis-1] summary “192.168.0.0。 “255.255.252.0。 [ level-1 | level-1-2 | level-2 ] [ avoid-feedback ] [ generate_null0_route ] [ tag “111。 ]");
							instruArr[1] = createCmdInstruSpan("“192.168.0.0。","汇总地址");
							instruArr[2] = createCmdInstruSpan("“255.255.252.0。","汇总掩码");
							instruArr[3] = createCmdInstruSpan("[ level-1 | level-1-2 | level-2 ]","被汇总的路由类型，默认为 level-2，level-1-2表示level-1和level-2");
							instruArr[4] = createCmdInstruSpan("avoid-feedback","避免本地路由器通过SPF计算再次学习到这条路由");
							instruArr[5] = createCmdInstruSpan("generate_null0_route","在本地生成一条将汇总地址指向NULL0的黑洞路由");
							instruArr[6] = createCmdInstruSpan("tag “111。","为汇总路由分配管理标记");
							instruArr[7] = createCmdInstruSpan("‘对于汇总域内路由，被汇总的路由至少有一条在本地通告。");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("发布默认路由");
							instruArr[0] = createCmdSpan("[R1-isis-1] default-route-advertise cost “30。 [ level-1 | level-1-2 | level-2 ] tag “111。 avoid-learning");
							instruArr[1] = createCmdInstruSpan("“30。","路由度量值");
							instruArr[2] = createCmdInstruSpan("[ level-1 | level-1-2 | level-2 ]","路由类型，默认为 level-2");
							instruArr[3] = createCmdInstruSpan("tag “111。","为汇总路由分配管理标记");
							instruArr[4] = createCmdInstruSpan("avoid-feedback","避免本地路由器通过SPF计算再次学习到这条路由");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("度量值设置");
							createInstruT3("设置度量值类型");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-isis-1] cost-style { narrow | narrow-compatible | wide | wide-compatible | compatible }");
								instruArr[1] = createCmdInstruSpan("narrow","只发送和接收窄度量值");
								instruArr[2] = createCmdInstruSpan("narrow-compatible","接收宽和窄度量值，只发送窄度量值");
								instruArr[3] = createCmdInstruSpan("wide","只发送和接收宽度量值");
								instruArr[4] = createCmdInstruSpan("wide-compatible","接收宽和窄度量值，只发送宽度量值");
								instruArr[5] = createCmdInstruSpan("compatible","发送和接收宽和窄度量值");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("设置度量值自动计算（度量值类型仅 wide / wide-compatible 时有效）");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-isis-1] bandwidth-reference “1000。");
								instruArr[1] = createCmdInstruSpan("“1000。","带宽参考值，度量值=带宽参考值/带宽*10");
								instruArr[2] = createCmdSpan("[R1-isis-1] auto-cost enable");
								createCmdInstruT3(instruArr,"huawei");

					createInstruT1("认证","i7-2");
						createInstruT2("链路认证");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis authentication-mode { { simple | md5 } [ cipher | plain ] “huawei。 | keychain “isis-key。 } [ level-1 | level-2 ]");
							instruArr[1] = createCmdInstruSpan("simple","明文认证");
							instruArr[2] = createCmdInstruSpan("md5","密文认证");
							instruArr[3] = createCmdInstruSpan("cipher","密钥密文存储（默认）");
							instruArr[4] = createCmdInstruSpan("plain","密钥明文存储");
							instruArr[5] = createCmdInstruSpan("keychain “isis-key。","通过keychain，配置认证，keychain名");
							instruArr[6] = createCmdInstruSpan("level-1 | level-2","只对level-1或level-2的hello包做认证，默认两者均认证");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("区域认证(‘不影响邻居关系，只影响level-1的路由。)");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-isis-1] area-authentication-mode { { simple | md5 } [ cipher | plain ] “huawei。 | keychain “isis-key。 }");
							instruArr[1] = createCmdInstruSpan("simple","明文认证");
							instruArr[2] = createCmdInstruSpan("md5","密文认证");
							instruArr[3] = createCmdInstruSpan("cipher","密钥密文存储（默认）");
							instruArr[4] = createCmdInstruSpan("plain","密钥明文存储");
							instruArr[5] = createCmdInstruSpan("keychain “isis-key。","通过keychain，配置认证，keychain名");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("域(AS)认证(‘不影响邻居关系，只影响level-2的路由。)");
							instruArr[0] = createCmdSpan("[R1-isis-1] domain-authentication-mode { { simple | md5 } [ cipher | plain ] “huawei。 | keychain “isis-key。 }");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("与BFD联动","i7-3");
						createInstruT2("动态全局模式，所有启用RIP的接口都生效","i7-3-1");
							createInstruT3("启用BFD");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] bfd");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("全局启用");
								instruArr[0] = createCmdSpan("[R1-isis-1] bfd all-interfaces enable");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("某些接口不启用");
								instruArr[0] = createCmdSpan("[R1] int “g0/0/1。");
								instruArr[1] = createCmdInstruSpan("“g0/0/1。","不启用BFD的接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/1] isis bfd block");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("调整BFD参数");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-isis-1] bfd all-interfaces “参数。 “参数值。");
								instruArr[1] = createCmdInstruSpan("参数含义同普通BFD");
								instruArr[1] = createCmdInstruSpan("isis的BFD增加了个 frr-binding ，启用后，当BFD session DOWN后，接口也会DOWN");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("动态接口模式","i7-3-2");
							createInstruT3("启用BFD");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] bfd");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("接口启用");
								instruArr[0] = createCmdSpan("[R1] int “g0/0/1。");
								instruArr[1] = createCmdInstruSpan("“g0/0/1。","启用BFD的接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/1] isis bfd enable");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("调整BFD参数");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/1] isis bfd “参数。 “参数值。");
								instruArr[1] = createCmdInstruSpan("参数含义同普通BFD");
								instruArr[1] = createCmdInstruSpan("isis的BFD增加了个 frr-binding ，启用后，当BFD session DOWN后，接口也会DOWN");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("静态模式","i7-3-3");
							createInstruT3("支持单臂回声和普通单跳，‘不支持多跳。");
							createInstruT3("先配置单臂回声或普通单跳BFD");
							createInstruT3("与接口相关联");
								instruArr[0] = createCmdSpan("[R1] int g0/0/0");
								instruArr[1] = createCmdInstruSpan("“g0/0/0。","静态单跳的出接口");
								instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0/0] isis bfd static");
								createCmdInstruT3(instruArr,"huawei");

				createInstruT0("边界网关协议(BGP)","i8");
					createInstruT1("基本配置","i8-1");
						createInstruT2("启用BGP");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] bgp “65510。");
							instruArr[1] = createCmdInstruSpan("“65510。","自治系统号");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置BGP路由器ID");
							instruArr[0] = createCmdSpan("[R1-bgp] router-id “1.1.1.1。");
							instruArr[1] = createCmdInstruSpan("“1.1.1.1。","Route ID");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("建立对等体组");
							createInstruT3("设置名称");
								instruArr[0] = createCmdSpan("[R1-bgp] group “bgp-group。 { internal | external }");
								instruArr[1] = createCmdInstruSpan("bgp-group","对等体组名");
								instruArr[2] = createCmdInstruSpan("internal","IBGP对等体组");
								instruArr[3] = createCmdInstruSpan("external","EBGP对等体组");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("配置对等体组的成员");
								instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 group “bgp-group。");
								instruArr[1] = createCmdSpan("[R1-bgp]……");
								instruArr[2] = createCmdInstruSpan("“2.2.2.2。","成员更新源地址");
								instruArr[3] = createCmdInstruSpan("“bgp-group。","对等体组名");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("指定BGP对等体(组)");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “192.168.12.1。 | “bgp-group。 } as-number “65520。");
							instruArr[1] = createCmdInstruSpan("“192.168.12.1。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							instruArr[3] = createCmdInstruSpan("“65520。","对等体(组)的AS号");
							createCmdInstruT2(instruArr,"huawei");
							createInstruAllBottomT2("使用对等体组时，如果为IBGP关系，因为配置对等体组时已经声明为IBGP，无需配置本条(配置会报错)");

						createInstruT2("修改BGP更新源，当两端更新源与目的地址不匹配时配置，两边均要配置");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “192.168.12.1。 | “bgp-group。 } connect-interface “loopback 0。");
							instruArr[3] = createCmdInstruSpan("“loopback 0。","本方更新源接口");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改EBGP报文TTL值(‘默认为1。)");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “192.168.12.1。 | “bgp-group。 } ebgp-max-hop [ “5。 ]");
							instruArr[3] = createCmdInstruSpan("“5。","TTL值，省略会自动设置为255");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("将EBGP报文传送给IBGP对等体(组)时，把下一跳改为本地对等体的更新源");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “192.168.12.1。 | “bgp-group。 } next-hop-local");
							instruArr[1] = createCmdInstruSpan("“192.168.12.1。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("将本路由器的BGP设置被动接收状态，只能由对方主动出起BGP连接");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “192.168.12.1。 | “bgp-group。 } listen-only");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("AS欺骗");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “192.168.12.1。 | “bgp-group。 } fake-as “65535。");
							instruArr[3] = createCmdInstruSpan("“65535。","伪装的AS号，对等体仅保留伪装的AS号");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("宣告网络");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] network “192.168.10.1。 [ “24。 | “255.255.255.0。 ]");
							instruArr[1] = createCmdInstruSpan("“192.168.10.1。","宣告的网络");
							instruArr[2] = createCmdInstruSpan("“24。","子网掩码长度");
							instruArr[3] = createCmdInstruSpan("“255.255.255.0。","子网掩码");
							instruArr[4] = createCmdInstruSpan("省略按标准的A、B、C的类处理");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("查看与重置命令","i8-8");
						createInstruT2("查看邻居表");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] display bgp peer");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("查看BGP表路由表");
							instruArr[0] = createCmdSpan("[R1] display bgp routing-table");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("查看向邻居发送/接收的路由条目");
							instruArr[0] = createCmdSpan("[R1] display bgp routing-table peer “192.168.12.2。 { advertised-routes | received-routes }");
							instruArr[1] = createCmdInstruSpan("“192.168.12.1。","对等体更新源地址");
							instruArr[2] = createCmdInstruSpan("advertised-routes","发送的路由");
							instruArr[3] = createCmdInstruSpan("received-routes","接收的路由");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("重置BGP连接");
							createInstruT3("硬重置，切断对等体关系，重新建立连接");
								instruArr[0] = createCmdSpan("&lt;R1> reset bgp { “2.2.2.2。 | group “bgp-group。 | all }");
								instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源地址");
								instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
								instruArr[3] = createCmdInstruSpan("all","所有对等体");
								createCmdInstruT2(instruArr,"huawei");

							createInstruT3("软重置，不切断对等体关系，刷新路由表");
								instruArr[0] = createCmdSpan("&lt;R1> refresh bgp { “2.2.2.2。 | group “bgp-group。 | all } { export | import }");
								instruArr[4] = createCmdInstruSpan("export","发出的路由");
								instruArr[5] = createCmdInstruSpan("import","接收的路由");
								createCmdInstruT2(instruArr,"huawei");

					createInstruT1("路由聚合","i8-9");
						createInstruT2("自动聚合");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] summary automatic");
							instruArr[1] = createCmdInstruSpan("只能聚合本地重分发进BGP的路由，network的路由无效，且只能聚合为标准的A、B、C类");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置路由聚合");
							instruArr[0] = createCmdSpan("[R1-bgp] aggregate “192.168.8.0。 “255.255.252.0。 [ detail-suppressed ] [ as-set ] [ suppress-policy “supName。 ] [ attribute-policy “attName。 ] ");
							instruArr[1] = createCmdInstruSpan("“192.168.8.0。","聚合地址");
							instruArr[2] = createCmdInstruSpan("“255.255.252.0。","聚合掩码");
							instruArr[3] = createCmdInstruSpan("detail-suppressed","只发送聚合路由，不设置明细和聚合一起发送");
							instruArr[4] = createCmdInstruSpan("as-set","聚合路由条目会携带明细路由的相应属性（如:as-path），应用于‘聚合非本地起源。的路由条目时，防止路由逆向传递");
							instruArr[5] = createCmdInstruSpan("suppress-policy “supName。","通过route-policy匹配到路由条目会被‘阻止。发送");
							instruArr[6] = createCmdInstruSpan("attribute-policy “attName。","通过route-policy修改聚合路由的属性，一般只能修改起源属性和团体属性");
							instruArr[7] = createCmdInstruSpan("“supName。 | “attName。","route-policy名");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("团体属性","i8-10");
						createInstruT2("通过 route-policy 配置用于控制路由的团体属性","i8-10-1");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-route-policy] apply community { no-export | no-export-subconfed | no-advertise }");
							instruArr[1] = createCmdInstruSpan("no-export","路由不传递出本AS，AS为真实的AS，联邦的子AS间可以传递路由");
							instruArr[2] = createCmdInstruSpan("no-export-subconfed","路由不传递出联邦的子AS，真实AS也不可以");
							instruArr[3] = createCmdInstruSpan("no-advertise","路由不传递给任何对等体");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("通过 route-policy 配置用于标记路由的团体属性","i8-10-2");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R4-route-policy] apply community “100:4。");
							instruArr[1] = createCmdInstruSpan("“100:4。","路由标记，一般用路由的AS号:某个数值表示");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置向BGP对等体发送团体属性，不配置不发送","i8-10-3");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “192.168.12.1。 | “bgp-group。 } advertise-community");
							instruArr[1] = createCmdInstruSpan("“192.168.12.1。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("获取并处理被标记的路由","i8-10-4");
							createInstruT3("配置community-filter匹配路由","i8-10-4");
								instruArr[0] = createCmdSpan("[R1] ip community-filter “10。 { permit | deny } “100:4。");
								instruArr[1] = createCmdInstruSpan("“10。","基本的community-filter号，范围1~99");
								instruArr[2] = createCmdInstruSpan("permit","匹配");
								instruArr[3] = createCmdInstruSpan("deny","不匹配");
								instruArr[4] = createCmdInstruSpan("“100:4。","路由标记");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("通过 route-policy 获取community-filter匹配的路由，并做相应处理");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-route-policy] if-match community-filter “10。 ");
								instruArr[1] = createCmdInstruSpan("“10。","community-filter号");
								instruArr[2] = createCmdSpan("[R1-route-policy] apply “…。 ");
								createCmdInstruT3(instruArr,"huawei");

					createInstruT1("BGP选路属性","i8-2");
						createInstruT2("修改优先数值(preferred-value，相当于思科的weight)","i8-2-1");
							createInstruT3("通过route-policy选取路由条目进行修改");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 route-policy “policyName。 import");
								instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源地址");
								instruArr[2] = createCmdInstruSpan("“policyName。","route-policy名<br />通过 apply preferred-value { “优先数值。 } 修改");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("修改来自某一邻居的‘全部。路由的preferred-value");
								instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 preferred-value “1。");
								instruArr[2] = createCmdInstruSpan("“1。","优先数值");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("修改本地优先级(local preference)","i8-2-2");
							createInstruT3("通过route-policy选取路由条目进行修改(‘出口路由器的入方向。设置)");
								instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 route-policy “policyName。 import");
								instruArr[2] = createCmdInstruSpan("“policyName。","route-policy名<br />route-policy名，通过apple local-preference { “本地优先级值。 } 修改");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("修改‘本地产生。(‘本地通告及重分发。)的及‘EBGP路由。");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] default local-preference “110。");
								instruArr[1] = createCmdInstruSpan("“110。","local preference值");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("修改自治系统路径(AS-Path)","i8-2-3");
							createInstruT3("通过route-policy选取路由条目进行修改");
								instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 route-policy “policyName。 { export | import }");
								instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源地址");
								instruArr[2] = createCmdInstruSpan("“policyName。","route-policy名<br />通过apply as-path { “as-path列表。 } additive 修改");
								instruArr[3] = createCmdInstruSpan("export","出方向");
								instruArr[4] = createCmdInstruSpan("import","入方向");
								createCmdInstruT3(instruArr,"huawei");
								createInstruAllBottomT3("<br />为防止影响路由传递，as-path列表中可使用私有AS号，或重复在原as-path中已经存在的AS号<br />");

							createInstruT3("设置as-path最大接收长度，as-path长度超过的路由将被丢弃");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] as-path-limit “10。");
								instruArr[1] = createCmdInstruSpan("“10。","as-path最大长度");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("向对等体发送的路由中去掉as-path中的私有as号");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] peer “12.1.1.1。 public-as-only");
								instruArr[1] = createCmdInstruSpan("“12.1.1.1。","对等体更新源地址");
								createCmdInstruT3(instruArr,"huawei");
								createInstruAllBottomT3("<br />当as-path中的私有as号的路由发往公网，可能会造成问题，需要去掉");
								createInstruAllBottomT3("在私有AS设备上配置无效，对等体为私有AS设备时配置无效，其它情况生效");

							createInstruT3("不比较as-path属性，‘不建议设置。");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] bestpath as-path-ignore");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("修改起源属性(origin code)","i8-2-4");
							instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 route-policy “policyName。 { export | import }");
							instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源地址");
							instruArr[2] = createCmdInstruSpan("“policyName。","route-policy名，通过apply origin { igp | egp | incomplete } 修改");
							instruArr[3] = createCmdInstruSpan("export","出方向");
							instruArr[4] = createCmdInstruSpan("import","入方向");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("修改多出口鉴别器属性(MED)","i8-2-5");
							createInstruT3("修改MED，只能在‘发送EBGP路由的出方向。配置");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 route-policy “policyName。 export");
								instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源地址");
								instruArr[2] = createCmdInstruSpan("“policyName。","route-policy名，通过apply cost  { “MED值。 } 修改");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("无论来源是否为相同AS均比较MED(默认只有来自相同AS的不同路径路由才比较MED)");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] compare-different-as-med");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("启用负载均衡","i8-2-6");
							createInstruT3("当前8条选路规则都相同，可启用负载均衡，使路由实现多个下一跳，但BGP表中仍只有一个最优");
							createInstruT3("但无论是EBGP还是IBGP，路由只有来同一个AS，负载均衡才有效");
								instruArr[0] = createCmdSpan("[R1-bgp] [ ebgp | ibgp ] maximum load-balancing [ ebgp | ibgp ] “4。")
								instruArr[1] = createCmdInstruSpan("[R1-bgp][ ebgp | ibgp ]","实现EBGP或IBGP路由的负载均衡，省略为EBGP");
								instruArr[2] = createCmdInstruSpan("“4。","负载均衡的路由数，范围1~8");
								createCmdInstruT3(instruArr,"huawei");

					createInstruT1("路由反射器(Router Reflector)","i8-3");
						createInstruT2("指定对等体为Client，自己成为Server，未指定的对等体为Non-Client，路由属性不改变，客户端无需额外配置");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] peer “2.2.2.2。 reflect-client");
							instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源地址");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置路由反射器的集群ID");
							instruArr[0] = createCmdSpan("[R1-bgp] reflector cluster-id “10.10.10.10。");
							instruArr[1] = createCmdInstruSpan("“10.10.10.10。","集群ID");
							createCmdInstruT2(instruArr,"huawei");
							createInstruAllBottomT2("当反射器不止一个，所有反射器就配置相同的集群ID，用于防环");

						createInstruT2("BGP路由不加载到本地路由表，不影响其它");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] bgp-rib-only");;
							createCmdInstruT2(instruArr,"huawei");
							createInstruAllBottomT2("只是本地路由表中不显示，可以用display bgp routing查看");

					createInstruT1("联邦(confederation)","i8-4");
						createInstruT2("联邦内部路由器使用子AS号设置BGP，子AS号应为私有AS号");
							instruArr[0] = createCmdSpan("[R1] router bgp “65001。");
							instruArr[1] = createCmdInstruSpan("“65001。","子AS号，私有AS号");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("设置向外通告的公有AS号");
							instruArr[0] = createCmdSpan("[R1-bgp] confederation id “1。");
							instruArr[1] = createCmdInstruSpan("“1。","向外通告的AS号");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("指定对等体时，对联邦内部路由器使用私有子AS号，联邦外部仍使用向外通告的公有AS号");

						createInstruT2("声明为联邦内的EBGP邻接关系");
							instruArr[0] = createCmdSpan("[R1-bgp] confederation peer-as “65002。");
							instruArr[1] = createCmdInstruSpan("“65002。","联邦内的EBGP对等体AS号");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("控制路由更新","i8-5");
						createInstruT2("‘基于全局。，根据路由控制");
							instruArr[0] = createCmdSpan("[R1-bgp] filter-policy { “2000。 | acl-name “acl_bgp。 | ip-prefix “pre_bgp。 } { export [ “路由类型。 [ “路由选项。 ] ] | import }");
							instruArr[1] = createCmdInstruSpan("“2000。","使用标准ACL匹配，标准ACL号");
							instruArr[2] = createCmdInstruSpan("“acl_bgp。","使用命名的ACL匹配，ACL名");
							instruArr[3] = createCmdInstruSpan("“pre_bgp。","使用前缀列表匹配，前缀列表名");
							instruArr[4] = createCmdInstruSpan("export","发出的路由");
							instruArr[5] = createCmdInstruSpan("“路由类型。","被引入到BGP的路由原始类型，对network和import的路由均有效，如:static、ospf");
							instruArr[6] = createCmdInstruSpan("“路由选项。","如:ospf的进程号");
							instruArr[7] = createCmdInstruSpan("import","接收的路由");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("‘基于对等体(对等体组)。，根据路由控制");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “2.2.2.2。 | “bgp-group。 } filter-policy { “2000。 | acl-name “acl_bgp。 | ip-prefix “pre_bgp。 } { export | import }");
							instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							instruArr[3] = createCmdInstruSpan("“2000。","使用标准ACL匹配，标准ACL号");
							instruArr[4] = createCmdInstruSpan("“acl_bgp。","使用命名的ACL匹配，ACL名");
							instruArr[5] = createCmdInstruSpan("“pre_bgp。","使用前缀列表匹配，前缀列表名");
							instruArr[6] = createCmdInstruSpan("export","发出的路由");
							instruArr[7] = createCmdInstruSpan("import","接收的路由");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("‘基于对等体(对等体组)。，根据as-path控制");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “2.2.2.2。 | “bgp-group。 } as-path-filter { “10。 | “as_filter。 } { export | import }");
							instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							instruArr[3] = createCmdInstruSpan("“10。","as-path-filter号");
							instruArr[4] = createCmdInstruSpan("“as_filter。","as-path-filter名");
							instruArr[5] = createCmdInstruSpan("export","发出的路由");
							instruArr[6] = createCmdInstruSpan("import","接收的路由");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("‘基于对等体(对等体组)。，根据route-policy控制");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “2.2.2.2。 | “bgp-group。 } route-policy “rp_bgp。 { export | import }");
							instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							instruArr[3] = createCmdInstruSpan("“rp_bgp。","route-policy名");
							instruArr[4] = createCmdInstruSpan("export","发出的路由");
							instruArr[5] = createCmdInstruSpan("import","接收的路由");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("BGP认证","i8-6");
						createInstruT2("仅在建立对等体关系有效，对等体关系建立好后即使认证失败，对等体依然有效");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “2.2.2.2。 | “bgp-group。 } password { simple | cipher } “bgpkey。");
							instruArr[3] = createCmdInstruSpan("simple","密钥明文存储");
							instruArr[4] = createCmdInstruSpan("cipher","密钥密文存储");
							instruArr[5] = createCmdInstruSpan("“bgpkey。","认证密钥");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("与BFD联动","i8-7");
						createInstruT2("基于对等体(对等体组)启用");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “2.2.2.2。 | “bgp-group。 } bfd enable");
							instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("基于对等体组启用时，某些对等体不启用");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] peer “3.3.3.3。 bfd block");
							instruArr[1] = createCmdInstruSpan("“3.3.3.3。","不启用BFD的对等体更新源");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("调整BFD参数");
							instruArr[0] = createCmdSpan("[R1-bgp] peer { “2.2.2.2。 | “bgp-group。 } bfd “参数。  [ “参数值。 ]");
							instruArr[1] = createCmdInstruSpan("“2.2.2.2。","对等体更新源");
							instruArr[2] = createCmdInstruSpan("“bgp-group。","对等体组名称");
							instruArr[3] = createCmdInstruSpan("参数含义同普通BFD");
							createCmdInstruT2(instruArr,"huawei");

				createInstruT0("各种列表","i9");
					createInstruT1("ip-prefix","i9-2");
						instruArr[0] = createCmdSpan("[R1] ip ip-prefix “pre。 [ index “10。 ] permit “128.0.0.0。 “2。 [ greater-equal “8。 ] [ less-equal “24。 ]");
						instruArr[1] = createCmdInstruSpan("“pre。","ip-prefix名");
						instruArr[2] = createCmdInstruSpan("“10。","ip-prefix中每个条目的编号");
						instruArr[3] = createCmdInstruSpan("“128.0.0.0。","路由前缀");
						instruArr[4] = createCmdInstruSpan("“2。","以长度表示的通配符掩码");
						instruArr[5] = createCmdInstruSpan("“8。","ge值");
						instruArr[6] = createCmdInstruSpan("“24。","le值");
						createCmdInstruT1(instruArr,"huawei");

					createInstruT1("as-path-filter","i9-4");
						instruArr = null;
						instruArr = new Array();
						instruArr[0] = createCmdSpan("[R1] ip as-path-filter { “10。 | “as_list。 } permit “^10。");
						instruArr[1] = createCmdInstruSpan("“10。","as-path-filter号");
						instruArr[2] = createCmdInstruSpan("“as_list。","as-path-filter名");
						instruArr[3] = createCmdInstruSpan("“^10。","as-path-filter内容，正则表达示形式")
						createCmdInstruT1(instruArr,"huawei");

				createInstruT0("多协议标签交换(MPLS)","i10");
					createInstruT1("配置标签分发协议(LDP)","i10-1");
						createInstruT2("配置lsr-id，本设备上的环回接口地址，需要在本AS全局可达");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] mpls lsr-id “11.1.1.1。");
							instruArr[1] = createCmdInstruSpan("“11.1.1.1。","lsr-id");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("全局启用MPLS及LDP");
							instruArr[0] = createCmdSpan("[R1] mpls");
							instruArr[1] = createCmdSpan("[R1] mpls ldp");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("接口启用MPLS及LDP，只在参与MPLS流量转发的接口启用，不包括连接CE，以及连接其它AS的接口");
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/0] mpls");
							instruArr[1] = createCmdSpan("[R1-GigabitEthernet0/0/0] mpls ldp");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("由于特殊原因，lsr-id不可达时，配置使某接口地址建立邻居");
							instruArr[0] = createCmdSpan("[R1] int “g0/0。");
							instruArr[1] = createCmdInstruSpan("“g0/0。","接口名");
							instruArr[2] = createCmdSpan("[R1-GigabitEthernet0/0] mpls ldp transport-address interface");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("对客户隐藏P设备，CE及P设备不受影响，‘PE设备。配置");
							instruArr[0] = createCmdSpan("[R1] undo ttl propagate");
							instruArr[1] = createCmdSpan("&lt;R1> reset mpls ldp all");
							instruArr[2] = createCmdInstruSpan("需要重置LDP后才生效");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置LDP与IGP的同步，只支持链路状态协议");
							createInstruT3("启用同步，接口下配置");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/1] { ospf | isis } ldp-sync ");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("查看同步信息");
								instruArr[0] = createCmdSpan("[R1] display { ospf | isis } ldp-sync interface all");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("控制发送/接收的标签");
							instruArr[0] = createCmdSpan("[R1] mpls ldp");
							instruArr[1] = createCmdSpan("[R1-mpls-ldp] { outbound | inbound } { peer “22.1.1.1。 | all | peer-group “ldp-group。 } fec ip-prefix “pre。");
							instruArr[2] = createCmdInstruSpan("{ outbound | inbound }","控制发送或接收的标签");
							instruArr[3] = createCmdInstruSpan("peer “22.1.1.1。","控制某个邻居的标签");
							instruArr[4] = createCmdInstruSpan("all","控制所有邻居的标签");
							instruArr[5] = createCmdInstruSpan("peer-group “ldp-group。","控制某个邻居组的标签");
							instruArr[6] = createCmdInstruSpan("“pre。","使用前缀列表匹配路由，前缀列表名");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("使用单播发现邻居，双向配置");
							instruArr[0] = createCmdSpan("[R1] mpls ldp remote-peer “mpls_peer。")
							instruArr[1] = createCmdInstruSpan("“mpls_peer。","邻居名");
							instruArr[2] = createCmdSpan("[R1-mpls-ldp-remote-mpls_peer] remote-ip “33.1.1.1。");
							instruArr[3] = createCmdInstruSpan("“33.1.1.1。","邻居的lsr-id");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置认证");
							instruArr[0] = createCmdSpan("[R1] mpls ldp");
							instruArr[1] = createCmdSpan("[R1-mpls-ldp] md5-password cipher “22.1.1.1。 “huawei。");
							instruArr[2] = createCmdInstruSpan("“22.1.1.1。","邻居的lsr-id");
							instruArr[3] = createCmdInstruSpan("“huawei。","认证密钥");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("查看/验证命令");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] display mpls ldp session");
							instruArr[1] = createCmdInstruSpan("‘Operational。为正常状态");
							instruArr[2] = createCmdSpan("[R1] display mpls ldp peer");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("查看标签转发表");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] display mpls lsp");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("验证LSP");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] tracert lsp ip “44.1.1.1。 32");
							instruArr[1] = createCmdInstruSpan("“44.1.1.1。","目的地址，‘华为默认只对32位路由分标签。");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("断开与邻居的连接");
							instruArr[0] = createCmdSpan("&lt;R1> reset mpls ldp { all | peer “44.1.1.1。 }")
							instruArr[1] = createCmdInstruSpan("“44.1.1.1。","邻居的lsr-id，或断开与所有邻居的连接");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("配置vpn-instance","i10-2");
						createInstruT2("创建vpn-instance");
							createInstruT3("创建vpn-instance");
								instruArr[0] = createCmdSpan("[R1] ip vpn-instance “VPN1。");
								instruArr[1] = createCmdInstruSpan("“VPN1。","vpn-instance名");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("配置RD值");
								instruArr[0] = createCmdSpan("[R1-vpn-instance-VPN1] route-distinguisher “100:1234。");
								instruArr[1] = createCmdInstruSpan("“100:1234。","RD值，一般配置规则为 AS号 : n，对于同一个客户，建议唯一");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("配置RT值");
								instruArr[0] = createCmdSpan("[R1-vpn-instance-VPN1] vpn-target  “100:1234。 [ export-extcommunity | import-extcommunity ]");
								instruArr[1] = createCmdInstruSpan("“100:1234。","RT值，一般配置规则为 AS号 : n");
								instruArr[2] = createCmdInstruSpan("[ export-extcommunity | import-extcommunity ]","省略则两个参数均配置<br />export-extcommunity : 更新VPNv4的路由<br />import-extcommunity : 接收的VPNv4的路由");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("接口加入vpn-instance");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0] ip binding vpn-instance “VPN1。");
							instruArr[1] = createCmdInstruSpan("“VPN1。","vpn-instance名，配置vpn-instance后，接口的IP地址会被清除");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("相关查看命令");
							instruArr[0] = createCmdSpan("[R1] vpn-instance ip vpn-instance [ “VPN1。 ]");
							instruArr[1] = createCmdSpan("[R1] vpn-instance ip vpn-instance [ “VPN1。 ] interface");
							instruArr[2] = createCmdInstruSpan("“VPN1。","vpn-instance名");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("配置MP-BGP","i10-3");
						createInstruT2("启用BGP VPNv4对等体");
							instruArr[0] = createCmdSpan("[R1] bgp “100。");
							instruArr[1] = createCmdInstruSpan("“100。","AS号");
							instruArr[2] = createCmdSpan("[R1-bgp] ipv4-family vpnv4");
							instruArr[3] = createCmdSpan("[R1-bgp-af-vpnv4] peer “33.1.1.1。 enable");
							instruArr[4] = createCmdInstruSpan("“33.1.1.1。","对等体地址");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("产生相应的vpn-instance路由");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1-bgp] ipv4-family vpn-instance “VPN1。 ");
							instruArr[1] = createCmdInstruSpan("“VPN1。","vpn-instance名");
							instruArr[2] = createCmdSpan("[R1-bgp-VPN1] network ……");
							instruArr[3] = createCmdSpan("[R1-bgp-VPN1] import-route ……");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("配置MPLS VPN中客户路由协议","i10-4");
						createInstruT2("静态路由","i10-4-1");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R1] ip route-static vpn-instance “VPN1。　“10.1.1.0。　“255.255.255.0。　“g0/0。　“10.1.18.8。");
							instruArr[1] = createCmdInstruSpan("“VPN1。","vpn-instance名");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("RIP","i10-4-2");
							instruArr[0] = createCmdSpan("[R1] rip [ “1。 ] vpn-instance “VPN1。");
							instruArr[2] = createCmdSpan("[R1-rip-1] ……");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("OSPF","i10-4-3");
							createInstruT3("基本配置");
								instruArr[0] = createCmdSpan("[R1] ospf [ “1。 ] vpn-instance “VPN1。");
								instruArr[2] = createCmdSpan("[R1-ospf-1] ……");
								createCmdInstruT3(instruArr,"huawei");
								createInstruAllBottomT3("<br />默认情况下，远端的PE和CE之间的链路在本地为OSPF外部路由，PE内部路由为OSPF区域间路由");

							createInstruT3("配置sham-link");
								instruArr[0] = createCmdSpan("[R1-ospf-1] area “0。");
								instruArr[1] = createCmdInstruSpan("“0。","区域号");
								instruArr[2] = createCmdSpan("[R1-ospf-1-area-0.0.0.0] sham-link “1.1.1.1。 “3.3.3.3。");
								instruArr[3] = createCmdInstruSpan("“1.1.1.1。","建立sham-link的本设备地址");
								instruArr[4] = createCmdInstruSpan("“3.3.3.3。","建立sham-link的对端设备地址");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("查看sham-link");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] display ospf sham-link");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("启用MCE(CE配置)");
								instruArr[0] = createCmdSpan("[R1-ospf-1] vpn-instance-capability simple");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("IS-IS","i10-4-4");
							createInstruT3("重分发到IS-IS的路由默认为level-2，根据需要调整level");
							instruArr[0] = createCmdSpan("[R1] isis [ “1。 ] vpn-instance “VPN1。");
							instruArr[1] = createCmdSpan("[R1-isis-1] ……");
							createCmdInstruT3(instruArr,"huawei");

						createInstruT2("BGP","i10-4-5");
							createInstruT3("使用BGP时，无需双向重分发，PE与CE建立邻居即可");
							createInstruT3("客户不同站点使用相同AS号时，因BGP防环机制，无接收路由");
							createInstruT3("‘主动方案，PE配置。，对向CE端发送的路由生效，将客户路由的AS号改为PE的AS号");
								instruArr[0] = createCmdSpan("[R1-bgp] ipv4-family vpn-instance VPN1");
								instruArr[1] = createCmdInstruSpan("“VPN1。","客户所属的vpn-instance名");
								instruArr[2] = createCmdSpan("[R1-bgp-VPN1] peer “10.1.12.2。 substitute-as ");
								instruArr[3] = createCmdInstruSpan("“10.1.12.2。","PE的更新源地址");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("‘被动方案，CE配置。，配置可以接收的路由中AS-path中与本AS号相同的次数");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R2-bgp] peer “10.1.12.1。 allow-as-loop [ “1。 ]");
								instruArr[1] = createCmdInstruSpan("“10.1.12.1。","CE的更新源地址");
								instruArr[2] = createCmdInstruSpan("“1。","可以接收的次数，默认为1");
								createCmdInstruT3(instruArr,"huawei");

					createInstruT1("客户路由的防环配置（PE配置）","i10-5");
						createInstruT2("链路状态协议（OSPF、IS&minus;IS），防环机制协议已经预置在协议内，无需额外配置","i10-5-1");
						createInstruT2("BGP","i10-5-2");
							instruArr[0] = createCmdSpan("[R1] bgp “100。");
							instruArr[1] = createCmdInstruSpan("“100。","AS号");
							instruArr[2] = createCmdSpan("[R1-bgp] ipv4-family vpn-instance “VPN1。");
							instruArr[3] = createCmdInstruSpan("“VPN1。","客户所属的vpn-instance名");
							instruArr[4] = createCmdSpan("[R1-bgp-VPN1] peer “10.1.38.8。 soo “100:34。");
							instruArr[5] = createCmdInstruSpan("“10.1.38.8。","CE的更新源地址");
							instruArr[6] = createCmdInstruSpan("“100:34。","soo值");
							createCmdInstruT2(instruArr,"huawei");


					createInstruT1("域间MPLS VPN解决方案","i10-6");
						createInstruT2("optionA","i10-6-1");
							createInstruT3("不同AS间互为CE/PE(使用BGP转发路由)，AS间为IP转发，‘只适用于VPN较少的情况。");
							createInstruT3("各AS内部配置方式与普通域内MPLS VPN相同，且不同AS内的vpn-instance的‘RT值无需匹配。");
							createInstruT3("ASBR间链路需要将接口加入对应的vpn-instance");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0] ip binding vpn-instance “AS-A-VPN。");
								instruArr[1] = createCmdInstruSpan("R1为域A的ASBR，g0/0与为域B连接的接口，AS-A-VPN为客户在域A中vpn-instance名");
								instruArr[2] = createCmdSpan("　");
								instruArr[3] = createCmdSpan("[R2-GigabitEthernet0/0] ip binding vpn-instance “AS-B-VPN。");
								instruArr[4] = createCmdInstruSpan("R2为域A的ASBR，g0/0与为域B连接的接口，AS-B-VPN为客户在域B中vpn-instance名");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("ASBR间建立BGP相应的vpn-instance地址族的邻居");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] ipv4-family vpn-instance “AS-A-VPN。");
								instruArr[1] = createCmdSpan("[R1-bgp-VPN1] peer ……");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("optionB","i10-6-2");
							createInstruT3("不同AS内的vpn-instance的‘RT值需要匹配。");
							createInstruT3("ASBR间链路只启用MPLS(不启用LDP)");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R2-GigabitEthernet0/0] mpls");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("ASBR间建立BGPVPNv4邻居");
								instruArr[0] = createCmdSpan("[R1-bgp] ipv4-family vpnv4");
								instruArr[1] = createCmdSpan("[R1-bgp-af-vpnv4] peer “33.1.1.1。 enable");
								instruArr[2] = createCmdInstruSpan("“33.1.1.1。","对端ASBR更新源地址");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("所有ASBR上BGP的VPNv4地址族关闭RT匹配功能");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-bgp] ipv4-family vpnv4");
								instruArr[1] = createCmdSpan("[R1-bgp-af-vpnv4] undo policy vpn-target");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("配置各个PE配置RT值，使其可以接收来自其它AS的路由");
								instruArr[0] = createCmdSpan("[R3] ip vpn-instance “VPN1。");
								instruArr[1] = createCmdInstruSpan("“VPN1。","客户的本AS中PE上配置的vpn-instance名");
								instruArr[2] = createCmdSpan("[R3-vpn-instance-VPN1] vpn-target “200:567。 import-extcommunity");
								instruArr[3] = createCmdInstruSpan("“200:567。","客户的‘对端AS中PE。上配置的RT发送值");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("optionC","i10-6-3");
							createInstruT3("不同AS内的vpn-instance的‘RT值需要匹配。");
							createInstruT3("不同AS的PE间建立VPNv4邻居");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R3-bgp] ipv4-family vpnv4");
								instruArr[1] = createCmdSpan("[R3-bgp-af-vpnv4] peer “7.7.7.7。 enable");
								instruArr[2] = createCmdInstruSpan("“7.7.7.7。","对端AS中PE的更新源地址");
								createCmdInstruT3(instruArr,"huawei");
								createInstruAllBottomT3("<br />由于去往对端PE更新源的标签由BGP分发，所以‘更新源地址不能在PE的BGP中宣告。");
								createInstruAllBottomT3("在PE上，更新源地址可以在AS内的IGP中宣告，在ASBR的BGP中宣告");
								//createInstruAllBottomT3("更新源地址在PE的BGP中宣告时，也可以在ASBR中把对端PE的更新源路由引入IGP，本端PE上就有对端的IGP路由，由LDP分发标签");

							createInstruT3("相同AS的PE与ASBR间，不同AS的ASBR间分发标签，ipv4地址族配置，双向配置");
								instruArr[0] = createCmdSpan("[R1-bgp] ipv4-family ipv4-family unicast");
								instruArr[1] = createCmdSpan("[R1-bgp-af-ipv4] peer “33.1.1.1。 label-route-capability");
								instruArr[2] = createCmdInstruSpan("“33.1.1.1。","对等体更新源地址");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("相同AS的PE与ASBR间，不同AS的ASBR间分发标签，ipv4地址族配置，双向配置");
								instruArr[0] = createCmdSpan("[R1-bgp] ipv4-family ipv4-family unicast");
								instruArr[1] = createCmdSpan("[R1-bgp-af-ipv4] peer “33.1.1.1。 label-route-capability");
								instruArr[2] = createCmdInstruSpan("“33.1.1.1。","对等体更新源地址");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("ASBR间链路只启用MPLS(不启用LDP)");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0] mpls");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("ASBR间配置标签分发，ipv4地址族配置，双向配置");
								instruArr[0] = createCmdSpan("[R1] route-policy “ASBR。 permit node “10。");
								instruArr[1] = createCmdInstruSpan("“ASBR。","标签分发策略名");
								instruArr[2] = createCmdInstruSpan("“10。","编号");
								instruArr[3] = createCmdSpan("[R1-route-policy] apply mpls-label");
								instruArr[4] = createCmdSpan("　");
								instruArr[5] = createCmdSpan("[R1-bgp] ipv4-family unicast");
								instruArr[6] = createCmdSpan("[R1-bgp-af-ipv4] peer “55.1.1.1。 route-policy “ASBR。 export");
								instruArr[7] = createCmdInstruSpan("“55.1.1.1。","对端ASBR更新源地址");
								instruArr[8] = createCmdInstruSpan("“ASBR。","标签分发策略名");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("同一AS内部，ASBR对PE配置标签分发，ipv4地址族配置，只需ASBR对PE配置");
								instruArr[0] = createCmdSpan("[R1] route-policy “toPE。 permit node “10。");
								instruArr[1] = createCmdInstruSpan("“toPE。","标签分发策略名");
								instruArr[3] = createCmdSpan("[R1-route-policy] if-match mpls-label");
								instruArr[4] = createCmdSpan("[R1-route-policy] apply mpls-label");
								instruArr[5] = createCmdSpan("　");
								instruArr[6] = createCmdSpan("[R1-bgp] ipv4-family unicast");
								instruArr[7] = createCmdSpan("[R1-bgp-af-ipv4] peer “33.1.1.1。 route-policy “toPE。 export");
								instruArr[8] = createCmdInstruSpan("“33.1.1.1。","PE更新源地址");
								instruArr[9] = createCmdInstruSpan("“toPE。","标签分发策略名");
								createCmdInstruT3(instruArr,"huawei");

				createInstruT0("组播","i11");
					createInstruT1("启用组播路由","i11-1");
						instruArr = null;
						instruArr = new Array();
						instruArr[0] = createCmdSpan("[R1] multicast routing-enable");
						createCmdInstruT1(instruArr,"huawei");

					createInstruT1("配置 PIM 稀疏模式","i11-2");
						createInstruT2("配置 PIM 稀疏模式，在所有互联接口、连接组播源和接收者的接口配置","i11-2-1");
							instruArr[0] = createCmdSpan("[R1-GigabitEthernet0/0/1] pim sm");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置IGMP，仅需在连接组播接收者的接口配置","i11-2-2");
							instruArr[0] = createCmdSpan("[R2-GigabitEthernet0/0/1] igmp enable");
							createCmdInstruT2(instruArr,"huawei");

					createInstruT1("配置RP","i11-3");
						createInstruT2("静态RP","i11-3-1");
							createInstruAllTopT2("一般配置为环回接口IP，需要网格可达，该接口无需启用pim");
							createInstruAllTopT2("所有转发组播流量设备均需配置");
							instruArr[0] = createCmdSpan("[R1] pim");
							instruArr[1] = createCmdSpan("[R1-pim] static-rp “11.11.11.11。 [ preferred ]");
							instruArr[2] = createCmdInstruSpan("“11.11.11.11。","静态RP地址");
							instruArr[3] = createCmdInstruSpan("preferred","当静态RP和BSR同时存在时，静态RP优先，不配置则BSR优先");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("BSR","i11-3-2");
							createInstruT3("配置候选BSR","i11-3-2-1");
								createInstruAllTopT3("一般配置为环回接口IP，需要网格可达，该接口需要启用pim");
								instruArr[0] = createCmdSpan("[R2] pim");
								instruArr[1] = createCmdSpan("[R2-pim] c-bsr “loop0。 [ “30。 [ “10。 ] ]");
								instruArr[2] = createCmdInstruSpan("“loop0。","候选BSR的接口");
								instruArr[3] = createCmdInstruSpan("“30。","哈希掩码长度，控制不方便，一般使用默认的30");
								instruArr[4] = createCmdInstruSpan("“10。","优先级，越大越优先，默认为0");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("配置候选RP","i11-3-2-2");
								createInstruAllTopT3("一般配置为环回接口IP，需要网格可达，该接口需要启用pim");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] pim");
								instruArr[1] = createCmdSpan("[R1-pim] c-rp “loop0。 [ priority “10。 ]");
								instruArr[2] = createCmdInstruSpan("“loop0。","候选BSR的接口");
								instruArr[3] = createCmdInstruSpan("“10。","优先级，越小越优先，默认为0");
								createCmdInstruT3(instruArr,"huawei");

						createInstruT2("anycast RP","i11-3-3");
							createInstruT3("配置RP","i11-3-3-1");
								createInstruAllTopT3("在两个设备上，分别配置环回接口，配置为相同的32主机地址，接口无需启用pim");
								createInstruAllTopT3("将该地址在所有组播设备上配置为静态RP");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R1] pim");
								instruArr[1] = createCmdSpan("[R1-pim] static-rp “11.11.11.11。");
								instruArr[2] = createCmdInstruSpan("“11.11.11.11。","静态RP地址");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("配置MSDP","i11-3-3-2");
								createInstruAllTopT3("在两个设备上，分别与对方建立MSDP邻居");
								instruArr[0] = createCmdSpan("[R1] msdp");
								instruArr[1] = createCmdSpan("[R1-msdp] peer “33.1.1.1。 connect-interface “loop 1。");
								instruArr[2] = createCmdInstruSpan("“33.1.1.1。","对端的更新源地址");
								instruArr[3] = createCmdInstruSpan("“loop 1。","本端的更新源接口");
								createCmdInstruT3(instruArr,"huawei");

					createInstruT1("配置扩展SSM","i11-4");
						createInstruT2("配置IGMPv3，仅需在连接组播接收者的接口配置","i11-4-1");
							instruArr = null;
							instruArr = new Array();
							instruArr[0] = createCmdSpan("[R2-GigabitEthernet0/0/1] igmp enable");
							instruArr[1] = createCmdSpan("[R2-GigabitEthernet0/0/1] igmp version 3");
							createCmdInstruT2(instruArr,"huawei");

						createInstruT2("配置SSM策略，所有组播设备配置","i11-4-2");
							createInstruT3("配置ACL匹配组播地址","i11-4-2-1");
								instruArr[0] = createCmdSpan("[R3] acl name “SSM。");
								instruArr[1] = createCmdInstruSpan("“SSM。","ACL名，通过扩展ACL的目的IP匹配组播地址");
								instruArr[2] = createCmdSpan("[R3-acl-adv-SSM] rule permit ip destination “239.1.1.1 0。");
								instruArr[3] = createCmdInstruSpan("“239.1.1.1 0。","组播地址");
								createCmdInstruT3(instruArr,"huawei");

							createInstruT3("PIM协议应用SSM策略","i11-4-2-2");
								instruArr = null;
								instruArr = new Array();
								instruArr[0] = createCmdSpan("[R3] pim");
								instruArr[1] = createCmdSpan("[R3-pim] ssm-policy acl-name “SSM。");
								instruArr[2] = createCmdInstruSpan("“SSM。","匹配组播地址的ACL名");
								createCmdInstruT3(instruArr,"huawei");




				document.write('<br /><br /><br /><br /><br /><br /><br /><br /><br />');
				document.write('<br /><br /><br /><br /><br /><br /><br /><br /><br />');
				document.write('<br /><br /><br /><br /><br /><br /><br /><br /><br />');
			</script>
		</div>
	</div>
</body>
</html>